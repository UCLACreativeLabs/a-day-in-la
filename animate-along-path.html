<html>

<head>
	<script src="https://rawgit.com/progers/pathseg/master/pathseg.js"></script>
	<script src="https://code.jquery.com/jquery-3.1.1.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/snap.svg/0.5.1/snap.svg.js"></script>
	<style type="text/css">
	svg {
		width: 300px;
		height: 300px;
	}
	</style>
</head>

<body>
	<svg id="svg"></svg>
	<script>

	// returns a matrix that transform points from src's coordinate system
	// to dest's coordinate system
	function transformBetween(src, dest) {
		var srcTransform = src.transform().globalMatrix;
		var destTransform = dest.transform().globalMatrix;
		return srcTransform.multLeft(destTransform.invert());
	}

	// modified from http://michaeltempest.com/the-missing-snap-svg-function/
	// "milestones" are control points to control speed along the path. The time between each milestone is constant, so put milestones close together on sections you want the object to move slowly
	// milestones: array of points along the path (in absolute distance)
	// duration: the time it should take to get to the next milestone
	function animateAlongPath(path, el, start, duration, milestones, animObj, easing, callback) {
		var len = Snap.path.getTotalLength(path),
			elBB = el.getBBox(),
			mat = transformBetween(path, el),
			milestones = milestones.concat([len]); // copy the array

		milestones.push(len); // add the path end point as a final milestone

		(function startFrame(currFrame, prevEnd) {
			var nextEnd = milestones[currFrame];
			animObj.anim = Snap.animate(prevEnd, nextEnd, function(value) {
				var pt = path.getPointAtLength(value);
				el.transform('t' + (mat.x(pt.x,pt.y) - elBB.cx) + ',' + (mat.y(pt.x,pt.y) - elBB.cy));
				//console.log(el.transform().string)
			}, duration, easing, function() {
				if (currFrame < milestones.length) startFrame(currFrame+1, nextEnd);
				else if (callback) callback(path);
			});
		})(0, start);
	};

	var s = Snap('#svg');
	var circle = s.circle(-10, -10, 10);
	Snap.load('testpath.svg', (imported) => {
		s.append(imported);
		var p = Snap('#path4146'),
			milestones = [],
			animObj = {};

		function reanimate() {
			animObj.anim && animObj.anim.stop();
			circle.transform(''); // initial transformation should be 0
			animateAlongPath(p, circle, 0, 500, milestones, animObj);
		}

		function createMilestone(x, y, length) {
			var elem = s.circle(x, y, 5);

			milestones.push(length);
			milestones.sort();
			elem.appendTo(s);
			elem.click((e) => {
				milestones.splice(milestones.indexOf(length), 1);
				elem.remove();
				e.preventDefault();
				e.stopPropagation();
				reanimate();
			});
			reanimate();
		}

		$("#svg").click(function (e) {
			var mat = p.transform().globalMatrix,
				matinv = mat.invert(),
				offset = [e.offsetX, e.offsetY],
				offsetRel = [matinv.x(...offset), matinv.y(...offset)];

			closest = Snap.closestPoint(p, ...offsetRel);
			if (closest.distance < 5) {
				var pt = [closest.x, closest.y]
				createMilestone(mat.x(...pt), mat.y(...pt), closest.length);
			}

			console.log(closest);
		});

		reanimate();
	});

	</script>
</body>

</html>
